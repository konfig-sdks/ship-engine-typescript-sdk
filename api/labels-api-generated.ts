/* tslint:disable */
/* eslint-disable */
/*
ShipEngine API

ShipEngine's easy-to-use REST API lets you manage all of your shipping needs without worrying about the complexities of different carrier APIs and protocols. We handle all the heavy lifting so you can focus on providing a first-class shipping experience for your customers at the best possible prices.

Each of ShipEngine's features can be used by itself or in conjunction with each other to build powerful shipping functionality into your application or service.

## Getting Started
If you're new to REST APIs then be sure to read our [introduction to REST](https://www.shipengine.com/docs/rest/) to understand the basics.  Learn how to [authenticate yourself to ShipEngine](https://www.shipengine.com/docs/auth/), and then use our [sandbox environment](https://www.shipengine.com/docs/sandbox/) to kick the tires and get familiar with our API. If you run into any problems, then be sure to check the [error handling guide](https://www.shipengine.com/docs/errors/) for tips.

Here are some step-by-step **tutorials** to get you started:

  - [Learn how to create your first shipping label](https://www.shipengine.com/docs/labels/create-a-label/)
  - [Calculate shipping costs and compare rates across carriers](https://www.shipengine.com/docs/rates/)
  - [Track packages on-demand or in real time](https://www.shipengine.com/docs/tracking/)
  - [Validate mailing addresses anywhere on Earth](https://www.shipengine.com/docs/addresses/validation/)


## Shipping Labels for Every Major Carrier
ShipEngine makes it easy to [create shipping labels for any carrier](https://www.shipengine.com/docs/labels/create-a-label/) and [download them](https://www.shipengine.com/docs/labels/downloading/) in a [variety of file formats](https://www.shipengine.com/docs/labels/formats/). You can even customize labels with your own [messages](https://www.shipengine.com/docs/labels/messages/) and [images](https://www.shipengine.com/docs/labels/branding/).


## Real-Time Package Tracking
With ShipEngine you can [get the current status of a package](https://www.shipengine.com/docs/tracking/) or [subscribe to real-time tracking updates](https://www.shipengine.com/docs/tracking/webhooks/) via webhooks. You can also create [custimized tracking pages](https://www.shipengine.com/docs/tracking/branded-tracking-page/) with your own branding so your customers will always know where their package is.


## Compare Shipping Costs Across Carriers
Make sure you ship as cost-effectively as possible by [comparing rates across carriers](https://www.shipengine.com/docs/rates/get-shipment-rates/) using the ShipEngine Rates API. Or if you don't know the full shipment details yet, then you can [get rate estimates](https://www.shipengine.com/docs/rates/estimate/) with limited address info.


## Worldwide Address Validation
ShipEngine supports [address validation](https://www.shipengine.com/docs/addresses/validation/) for virtually [every country on Earth](https://www.shipengine.com/docs/addresses/validation/countries/), including the United States, Canada, Great Britain, Australia, Germany, France, Norway, Spain, Sweden, Israel, Italy, and over 160 others.


The version of the OpenAPI document: 1.1.202403202303
Contact: sales@shipengine.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AlternativeIdentifier } from '../models';
// @ts-ignore
import { CreateLabelFromShipmentRequestBody } from '../models';
// @ts-ignore
import { CreateReturnLabelRequestBody } from '../models';
// @ts-ignore
import { DisplayScheme } from '../models';
// @ts-ignore
import { ErrorResponseBody } from '../models';
// @ts-ignore
import { Label } from '../models';
// @ts-ignore
import { LabelChargeEvent } from '../models';
// @ts-ignore
import { LabelDownload } from '../models';
// @ts-ignore
import { LabelDownloadType } from '../models';
// @ts-ignore
import { LabelFormDownload } from '../models';
// @ts-ignore
import { LabelFormat } from '../models';
// @ts-ignore
import { LabelInsuranceClaim } from '../models';
// @ts-ignore
import { LabelLayout } from '../models';
// @ts-ignore
import { LabelPackagesInner } from '../models';
// @ts-ignore
import { LabelStatus } from '../models';
// @ts-ignore
import { MonetaryValue } from '../models';
// @ts-ignore
import { PagedListResponseBody } from '../models';
// @ts-ignore
import { PartialShipment } from '../models';
// @ts-ignore
import { PurchaseLabelWithoutShipment } from '../models';
// @ts-ignore
import { SortDir } from '../models';
// @ts-ignore
import { TrackingInformation } from '../models';
// @ts-ignore
import { TrackingStatus } from '../models';
// @ts-ignore
import { ValidateAddress } from '../models';
// @ts-ignore
import { VoidLabelResponseBody } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * LabelsApi - axios parameter creator
 * @export
 */
export const LabelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a return label
         * @summary Create a return label
         * @param {string} labelId Label ID
         * @param {CreateReturnLabelRequestBody} createReturnLabelRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReturnLabel: async (labelId: string, createReturnLabelRequestBody: CreateReturnLabelRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('createReturnLabel', 'labelId', labelId)
            // verify required parameter 'createReturnLabelRequestBody' is not null or undefined
            assertParamExists('createReturnLabel', 'createReturnLabelRequestBody', createReturnLabelRequestBody)
            const localVarPath = `/v1/labels/{label_id}/return`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId !== undefined ? labelId : `-label_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "API-Key", keyParamName: "apiKey", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: createReturnLabelRequestBody,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/labels/{label_id}/return',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(createReturnLabelRequestBody, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a label by using the external shipment id that was used during label creation 
         * @summary Get Label By External Shipment ID
         * @param {string} externalShipmentId 
         * @param {LabelDownloadType} [labelDownloadType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByExternalShipmentId: async (externalShipmentId: string, labelDownloadType?: LabelDownloadType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalShipmentId' is not null or undefined
            assertParamExists('getByExternalShipmentId', 'externalShipmentId', externalShipmentId)
            const localVarPath = `/v1/labels/external_shipment_id/{external_shipment_id}`
                .replace(`{${"external_shipment_id"}}`, encodeURIComponent(String(externalShipmentId !== undefined ? externalShipmentId : `-external_shipment_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "API-Key", keyParamName: "apiKey", configuration })
            if (labelDownloadType !== undefined) {
                localVarQueryParameter['label_download_type'] = labelDownloadType;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/labels/external_shipment_id/{external_shipment_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for individual labels.
         * @summary Get Label By ID
         * @param {string} labelId Label ID
         * @param {LabelDownloadType} [labelDownloadType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (labelId: string, labelDownloadType?: LabelDownloadType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('getById', 'labelId', labelId)
            const localVarPath = `/v1/labels/{label_id}`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId !== undefined ? labelId : `-label_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "API-Key", keyParamName: "apiKey", configuration })
            if (labelDownloadType !== undefined) {
                localVarQueryParameter['label_download_type'] = labelDownloadType;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/labels/{label_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the label\'s tracking information
         * @summary Get Label Tracking Information
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingInfo: async (labelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('getTrackingInfo', 'labelId', labelId)
            const localVarPath = `/v1/labels/{label_id}/track`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId !== undefined ? labelId : `-label_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "API-Key", keyParamName: "apiKey", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/labels/{label_id}/track',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purchase and print a label for shipment
         * @summary Purchase Label
         * @param {Label} label 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        label: async (label: Label, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'label' is not null or undefined
            assertParamExists('label', 'label', label)
            const localVarPath = `/v1/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "API-Key", keyParamName: "apiKey", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: label,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/labels',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(label, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void a label by ID to get a refund.
         * @summary Void a Label By ID
         * @param {string} labelId Label ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        label_1: async (labelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('label_1', 'labelId', labelId)
            const localVarPath = `/v1/labels/{label_id}/void`
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId !== undefined ? labelId : `-label_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "API-Key", keyParamName: "apiKey", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/labels/{label_id}/void',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id` 
         * @summary List labels
         * @param {LabelStatus} [labelStatus] Only return labels that are currently in the specified status
         * @param {string} [serviceCode] Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
         * @param {string} [carrierId] Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
         * @param {string} [trackingNumber] Only return labels with a specific tracking number
         * @param {string} [batchId] Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
         * @param {string} [rateId] Rate ID
         * @param {string} [shipmentId] Shipment ID
         * @param {string} [warehouseId] Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
         * @param {string} [createdAtStart] Only return labels that were created on or after a specific date/time
         * @param {string} [createdAtEnd] Only return labels that were created on or before a specific date/time
         * @param {number} [page] Return a specific page of results. Defaults to the first page. If set to a number that\&#39;s greater than the number of pages of results, an empty page is returned. 
         * @param {number} [pageSize] The number of results to return per response.
         * @param {SortDir} [sortDir] Controls the sort order of the query.
         * @param {'modified_at' | 'created_at'} [sortBy] Controls which field the query is sorted by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labels: async (labelStatus?: LabelStatus, serviceCode?: string, carrierId?: string, trackingNumber?: string, batchId?: string, rateId?: string, shipmentId?: string, warehouseId?: string, createdAtStart?: string, createdAtEnd?: string, page?: number, pageSize?: number, sortDir?: SortDir, sortBy?: 'modified_at' | 'created_at', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "API-Key", keyParamName: "apiKey", configuration })
            if (labelStatus !== undefined) {
                localVarQueryParameter['label_status'] = labelStatus;
            }

            if (serviceCode !== undefined) {
                localVarQueryParameter['service_code'] = serviceCode;
            }

            if (carrierId !== undefined) {
                localVarQueryParameter['carrier_id'] = carrierId;
            }

            if (trackingNumber !== undefined) {
                localVarQueryParameter['tracking_number'] = trackingNumber;
            }

            if (batchId !== undefined) {
                localVarQueryParameter['batch_id'] = batchId;
            }

            if (rateId !== undefined) {
                localVarQueryParameter['rate_id'] = rateId;
            }

            if (shipmentId !== undefined) {
                localVarQueryParameter['shipment_id'] = shipmentId;
            }

            if (warehouseId !== undefined) {
                localVarQueryParameter['warehouse_id'] = warehouseId;
            }

            if (createdAtStart !== undefined) {
                localVarQueryParameter['created_at_start'] = (createdAtStart as any instanceof Date) ?
                    (createdAtStart as any).toISOString() :
                    createdAtStart;
            }

            if (createdAtEnd !== undefined) {
                localVarQueryParameter['created_at_end'] = (createdAtEnd as any instanceof Date) ?
                    (createdAtEnd as any).toISOString() :
                    createdAtEnd;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/labels',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly. 
         * @summary Purchase Label with Rate ID
         * @param {string} rateId Rate ID
         * @param {PurchaseLabelWithoutShipment} purchaseLabelWithoutShipment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLabelWithRateId: async (rateId: string, purchaseLabelWithoutShipment: PurchaseLabelWithoutShipment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rateId' is not null or undefined
            assertParamExists('purchaseLabelWithRateId', 'rateId', rateId)
            // verify required parameter 'purchaseLabelWithoutShipment' is not null or undefined
            assertParamExists('purchaseLabelWithRateId', 'purchaseLabelWithoutShipment', purchaseLabelWithoutShipment)
            const localVarPath = `/v1/labels/rates/{rate_id}`
                .replace(`{${"rate_id"}}`, encodeURIComponent(String(rateId !== undefined ? rateId : `-rate_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "API-Key", keyParamName: "apiKey", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: purchaseLabelWithoutShipment,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/labels/rates/{rate_id}',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(purchaseLabelWithoutShipment, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purchase a label using a shipment ID that has already been created with the desired address and package info. 
         * @summary Purchase Label with Shipment ID
         * @param {string} shipmentId Shipment ID
         * @param {CreateLabelFromShipmentRequestBody} createLabelFromShipmentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLabelWithShipmentId: async (shipmentId: string, createLabelFromShipmentRequestBody: CreateLabelFromShipmentRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shipmentId' is not null or undefined
            assertParamExists('purchaseLabelWithShipmentId', 'shipmentId', shipmentId)
            // verify required parameter 'createLabelFromShipmentRequestBody' is not null or undefined
            assertParamExists('purchaseLabelWithShipmentId', 'createLabelFromShipmentRequestBody', createLabelFromShipmentRequestBody)
            const localVarPath = `/v1/labels/shipment/{shipment_id}`
                .replace(`{${"shipment_id"}}`, encodeURIComponent(String(shipmentId !== undefined ? shipmentId : `-shipment_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "API-Key", keyParamName: "apiKey", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: createLabelFromShipmentRequestBody,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v1/labels/shipment/{shipment_id}',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(createLabelFromShipmentRequestBody, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LabelsApi - functional programming interface
 * @export
 */
export const LabelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LabelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a return label
         * @summary Create a return label
         * @param {LabelsApiCreateReturnLabelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReturnLabel(requestParameters: LabelsApiCreateReturnLabelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const createReturnLabelRequestBody: CreateReturnLabelRequestBody = {
                charge_event: requestParameters.charge_event,
                label_layout: requestParameters.label_layout,
                label_format: requestParameters.label_format,
                label_download_type: requestParameters.label_download_type,
                display_scheme: requestParameters.display_scheme,
                label_image_id: requestParameters.label_image_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReturnLabel(requestParameters.labelId, createReturnLabelRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find a label by using the external shipment id that was used during label creation 
         * @summary Get Label By External Shipment ID
         * @param {LabelsApiGetByExternalShipmentIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByExternalShipmentId(requestParameters: LabelsApiGetByExternalShipmentIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByExternalShipmentId(requestParameters.externalShipmentId, requestParameters.labelDownloadType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for individual labels.
         * @summary Get Label By ID
         * @param {LabelsApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(requestParameters: LabelsApiGetByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(requestParameters.labelId, requestParameters.labelDownloadType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the label\'s tracking information
         * @summary Get Label Tracking Information
         * @param {LabelsApiGetTrackingInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackingInfo(requestParameters: LabelsApiGetTrackingInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackingInfo(requestParameters.labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purchase and print a label for shipment
         * @summary Purchase Label
         * @param {LabelsApiLabelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async label(requestParameters: LabelsApiLabelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const label: Label = {
                label_id: requestParameters.label_id,
                status: requestParameters.status,
                shipment_id: requestParameters.shipment_id,
                shipment: requestParameters.shipment,
                ship_date: requestParameters.ship_date,
                created_at: requestParameters.created_at,
                shipment_cost: requestParameters.shipment_cost,
                insurance_cost: requestParameters.insurance_cost,
                requested_comparison_amount: requestParameters.requested_comparison_amount,
                tracking_number: requestParameters.tracking_number,
                is_return_label: requestParameters.is_return_label,
                rma_number: requestParameters.rma_number,
                is_international: requestParameters.is_international,
                batch_id: requestParameters.batch_id,
                carrier_id: requestParameters.carrier_id,
                charge_event: requestParameters.charge_event,
                outbound_label_id: requestParameters.outbound_label_id,
                service_code: requestParameters.service_code,
                test_label: requestParameters.test_label,
                package_code: requestParameters.package_code,
                validate_address: requestParameters.validate_address,
                voided: requestParameters.voided,
                voided_at: requestParameters.voided_at,
                label_download_type: requestParameters.label_download_type,
                label_format: requestParameters.label_format,
                display_scheme: requestParameters.display_scheme,
                label_layout: requestParameters.label_layout,
                trackable: requestParameters.trackable,
                label_image_id: requestParameters.label_image_id,
                carrier_code: requestParameters.carrier_code,
                tracking_status: requestParameters.tracking_status,
                label_download: requestParameters.label_download,
                form_download: requestParameters.form_download,
                insurance_claim: requestParameters.insurance_claim,
                packages: requestParameters.packages,
                alternative_identifiers: requestParameters.alternative_identifiers
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.label(label, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Void a label by ID to get a refund.
         * @summary Void a Label By ID
         * @param {LabelsApiLabel0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async label_1(requestParameters: LabelsApiLabel0Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoidLabelResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.label_1(requestParameters.labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id` 
         * @summary List labels
         * @param {LabelsApiLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labels(requestParameters: LabelsApiLabelsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedListResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.labels(requestParameters.labelStatus, requestParameters.serviceCode, requestParameters.carrierId, requestParameters.trackingNumber, requestParameters.batchId, requestParameters.rateId, requestParameters.shipmentId, requestParameters.warehouseId, requestParameters.createdAtStart, requestParameters.createdAtEnd, requestParameters.page, requestParameters.pageSize, requestParameters.sortDir, requestParameters.sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly. 
         * @summary Purchase Label with Rate ID
         * @param {LabelsApiPurchaseLabelWithRateIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseLabelWithRateId(requestParameters: LabelsApiPurchaseLabelWithRateIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const purchaseLabelWithoutShipment: PurchaseLabelWithoutShipment = {
                validate_address: requestParameters.validate_address,
                label_layout: requestParameters.label_layout,
                label_format: requestParameters.label_format,
                label_download_type: requestParameters.label_download_type,
                display_scheme: requestParameters.display_scheme
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseLabelWithRateId(requestParameters.rateId, purchaseLabelWithoutShipment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purchase a label using a shipment ID that has already been created with the desired address and package info. 
         * @summary Purchase Label with Shipment ID
         * @param {LabelsApiPurchaseLabelWithShipmentIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseLabelWithShipmentId(requestParameters: LabelsApiPurchaseLabelWithShipmentIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const createLabelFromShipmentRequestBody: CreateLabelFromShipmentRequestBody = {
                validate_address: requestParameters.validate_address,
                label_layout: requestParameters.label_layout,
                label_format: requestParameters.label_format,
                label_download_type: requestParameters.label_download_type,
                display_scheme: requestParameters.display_scheme
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseLabelWithShipmentId(requestParameters.shipmentId, createLabelFromShipmentRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LabelsApi - factory interface
 * @export
 */
export const LabelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LabelsApiFp(configuration)
    return {
        /**
         * Create a return label
         * @summary Create a return label
         * @param {LabelsApiCreateReturnLabelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReturnLabel(requestParameters: LabelsApiCreateReturnLabelRequest, options?: AxiosRequestConfig): AxiosPromise<Label> {
            return localVarFp.createReturnLabel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a label by using the external shipment id that was used during label creation 
         * @summary Get Label By External Shipment ID
         * @param {LabelsApiGetByExternalShipmentIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByExternalShipmentId(requestParameters: LabelsApiGetByExternalShipmentIdRequest, options?: AxiosRequestConfig): AxiosPromise<Label> {
            return localVarFp.getByExternalShipmentId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for individual labels.
         * @summary Get Label By ID
         * @param {LabelsApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: LabelsApiGetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Label> {
            return localVarFp.getById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the label\'s tracking information
         * @summary Get Label Tracking Information
         * @param {LabelsApiGetTrackingInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingInfo(requestParameters: LabelsApiGetTrackingInfoRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingInformation> {
            return localVarFp.getTrackingInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Purchase and print a label for shipment
         * @summary Purchase Label
         * @param {LabelsApiLabelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        label(requestParameters: LabelsApiLabelRequest, options?: AxiosRequestConfig): AxiosPromise<Label> {
            return localVarFp.label(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Void a label by ID to get a refund.
         * @summary Void a Label By ID
         * @param {LabelsApiLabel0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        label_1(requestParameters: LabelsApiLabel0Request, options?: AxiosRequestConfig): AxiosPromise<VoidLabelResponseBody> {
            return localVarFp.label_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id` 
         * @summary List labels
         * @param {LabelsApiLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labels(requestParameters: LabelsApiLabelsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PagedListResponseBody> {
            return localVarFp.labels(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly. 
         * @summary Purchase Label with Rate ID
         * @param {LabelsApiPurchaseLabelWithRateIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLabelWithRateId(requestParameters: LabelsApiPurchaseLabelWithRateIdRequest, options?: AxiosRequestConfig): AxiosPromise<Label> {
            return localVarFp.purchaseLabelWithRateId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Purchase a label using a shipment ID that has already been created with the desired address and package info. 
         * @summary Purchase Label with Shipment ID
         * @param {LabelsApiPurchaseLabelWithShipmentIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLabelWithShipmentId(requestParameters: LabelsApiPurchaseLabelWithShipmentIdRequest, options?: AxiosRequestConfig): AxiosPromise<Label> {
            return localVarFp.purchaseLabelWithShipmentId(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createReturnLabel operation in LabelsApi.
 * @export
 * @interface LabelsApiCreateReturnLabelRequest
 */
export type LabelsApiCreateReturnLabelRequest = {
    
    /**
    * Label ID
    * @type {string}
    * @memberof LabelsApiCreateReturnLabel
    */
    readonly labelId: string
    
} & CreateReturnLabelRequestBody

/**
 * Request parameters for getByExternalShipmentId operation in LabelsApi.
 * @export
 * @interface LabelsApiGetByExternalShipmentIdRequest
 */
export type LabelsApiGetByExternalShipmentIdRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof LabelsApiGetByExternalShipmentId
    */
    readonly externalShipmentId: string
    
    /**
    * 
    * @type {LabelDownloadType}
    * @memberof LabelsApiGetByExternalShipmentId
    */
    readonly labelDownloadType?: LabelDownloadType
    
}

/**
 * Request parameters for getById operation in LabelsApi.
 * @export
 * @interface LabelsApiGetByIdRequest
 */
export type LabelsApiGetByIdRequest = {
    
    /**
    * Label ID
    * @type {string}
    * @memberof LabelsApiGetById
    */
    readonly labelId: string
    
    /**
    * 
    * @type {LabelDownloadType}
    * @memberof LabelsApiGetById
    */
    readonly labelDownloadType?: LabelDownloadType
    
}

/**
 * Request parameters for getTrackingInfo operation in LabelsApi.
 * @export
 * @interface LabelsApiGetTrackingInfoRequest
 */
export type LabelsApiGetTrackingInfoRequest = {
    
    /**
    * Label ID
    * @type {string}
    * @memberof LabelsApiGetTrackingInfo
    */
    readonly labelId: string
    
}

/**
 * Request parameters for label operation in LabelsApi.
 * @export
 * @interface LabelsApiLabelRequest
 */
export type LabelsApiLabelRequest = {
    
} & Label

/**
 * Request parameters for label_1 operation in LabelsApi.
 * @export
 * @interface LabelsApiLabel0Request
 */
export type LabelsApiLabel0Request = {
    
    /**
    * Label ID
    * @type {string}
    * @memberof LabelsApiLabel0
    */
    readonly labelId: string
    
}

/**
 * Request parameters for labels operation in LabelsApi.
 * @export
 * @interface LabelsApiLabelsRequest
 */
export type LabelsApiLabelsRequest = {
    
    /**
    * Only return labels that are currently in the specified status
    * @type {LabelStatus}
    * @memberof LabelsApiLabels
    */
    readonly labelStatus?: LabelStatus
    
    /**
    * Only return labels for a specific [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/)
    * @type {string}
    * @memberof LabelsApiLabels
    */
    readonly serviceCode?: string
    
    /**
    * Only return labels for a specific [carrier account](https://www.shipengine.com/docs/carriers/setup/)
    * @type {string}
    * @memberof LabelsApiLabels
    */
    readonly carrierId?: string
    
    /**
    * Only return labels with a specific tracking number
    * @type {string}
    * @memberof LabelsApiLabels
    */
    readonly trackingNumber?: string
    
    /**
    * Only return labels that were created in a specific [batch](https://www.shipengine.com/docs/labels/bulk/)
    * @type {string}
    * @memberof LabelsApiLabels
    */
    readonly batchId?: string
    
    /**
    * Rate ID
    * @type {string}
    * @memberof LabelsApiLabels
    */
    readonly rateId?: string
    
    /**
    * Shipment ID
    * @type {string}
    * @memberof LabelsApiLabels
    */
    readonly shipmentId?: string
    
    /**
    * Only return labels that originate from a specific [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/)
    * @type {string}
    * @memberof LabelsApiLabels
    */
    readonly warehouseId?: string
    
    /**
    * Only return labels that were created on or after a specific date/time
    * @type {string}
    * @memberof LabelsApiLabels
    */
    readonly createdAtStart?: string
    
    /**
    * Only return labels that were created on or before a specific date/time
    * @type {string}
    * @memberof LabelsApiLabels
    */
    readonly createdAtEnd?: string
    
    /**
    * Return a specific page of results. Defaults to the first page. If set to a number that\'s greater than the number of pages of results, an empty page is returned. 
    * @type {number}
    * @memberof LabelsApiLabels
    */
    readonly page?: number
    
    /**
    * The number of results to return per response.
    * @type {number}
    * @memberof LabelsApiLabels
    */
    readonly pageSize?: number
    
    /**
    * Controls the sort order of the query.
    * @type {SortDir}
    * @memberof LabelsApiLabels
    */
    readonly sortDir?: SortDir
    
    /**
    * Controls which field the query is sorted by.
    * @type {'modified_at' | 'created_at'}
    * @memberof LabelsApiLabels
    */
    readonly sortBy?: 'modified_at' | 'created_at'
    
}

/**
 * Request parameters for purchaseLabelWithRateId operation in LabelsApi.
 * @export
 * @interface LabelsApiPurchaseLabelWithRateIdRequest
 */
export type LabelsApiPurchaseLabelWithRateIdRequest = {
    
    /**
    * Rate ID
    * @type {string}
    * @memberof LabelsApiPurchaseLabelWithRateId
    */
    readonly rateId: string
    
} & PurchaseLabelWithoutShipment

/**
 * Request parameters for purchaseLabelWithShipmentId operation in LabelsApi.
 * @export
 * @interface LabelsApiPurchaseLabelWithShipmentIdRequest
 */
export type LabelsApiPurchaseLabelWithShipmentIdRequest = {
    
    /**
    * Shipment ID
    * @type {string}
    * @memberof LabelsApiPurchaseLabelWithShipmentId
    */
    readonly shipmentId: string
    
} & CreateLabelFromShipmentRequestBody

/**
 * LabelsApiGenerated - object-oriented interface
 * @export
 * @class LabelsApiGenerated
 * @extends {BaseAPI}
 */
export class LabelsApiGenerated extends BaseAPI {
    /**
     * Create a return label
     * @summary Create a return label
     * @param {LabelsApiCreateReturnLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApiGenerated
     */
    public createReturnLabel(requestParameters: LabelsApiCreateReturnLabelRequest, options?: AxiosRequestConfig) {
        return LabelsApiFp(this.configuration).createReturnLabel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find a label by using the external shipment id that was used during label creation 
     * @summary Get Label By External Shipment ID
     * @param {LabelsApiGetByExternalShipmentIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApiGenerated
     */
    public getByExternalShipmentId(requestParameters: LabelsApiGetByExternalShipmentIdRequest, options?: AxiosRequestConfig) {
        return LabelsApiFp(this.configuration).getByExternalShipmentId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for individual labels.
     * @summary Get Label By ID
     * @param {LabelsApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApiGenerated
     */
    public getById(requestParameters: LabelsApiGetByIdRequest, options?: AxiosRequestConfig) {
        return LabelsApiFp(this.configuration).getById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the label\'s tracking information
     * @summary Get Label Tracking Information
     * @param {LabelsApiGetTrackingInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApiGenerated
     */
    public getTrackingInfo(requestParameters: LabelsApiGetTrackingInfoRequest, options?: AxiosRequestConfig) {
        return LabelsApiFp(this.configuration).getTrackingInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purchase and print a label for shipment
     * @summary Purchase Label
     * @param {LabelsApiLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApiGenerated
     */
    public label(requestParameters: LabelsApiLabelRequest, options?: AxiosRequestConfig) {
        return LabelsApiFp(this.configuration).label(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void a label by ID to get a refund.
     * @summary Void a Label By ID
     * @param {LabelsApiLabel0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApiGenerated
     */
    public label_1(requestParameters: LabelsApiLabel0Request, options?: AxiosRequestConfig) {
        return LabelsApiFp(this.configuration).label_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of labels that you\'ve [created](https://www.shipengine.com/docs/labels/create-a-label/). You can optionally filter the results as well as control their sort order and the number of results returned at a time.  By default, all labels are returned, 25 at a time, starting with the most recently created ones.  You can combine multiple filter options to narrow-down the results.  For example, if you only want to get your UPS labels for your east coast warehouse you could query by both `warehouse_id` and `carrier_id` 
     * @summary List labels
     * @param {LabelsApiLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApiGenerated
     */
    public labels(requestParameters: LabelsApiLabelsRequest = {}, options?: AxiosRequestConfig) {
        return LabelsApiFp(this.configuration).labels(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When retrieving rates for shipments using the `/rates` endpoint, the returned information contains a `rate_id` property that can be used to generate a label without having to refill in the shipment information repeatedly. 
     * @summary Purchase Label with Rate ID
     * @param {LabelsApiPurchaseLabelWithRateIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApiGenerated
     */
    public purchaseLabelWithRateId(requestParameters: LabelsApiPurchaseLabelWithRateIdRequest, options?: AxiosRequestConfig) {
        return LabelsApiFp(this.configuration).purchaseLabelWithRateId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purchase a label using a shipment ID that has already been created with the desired address and package info. 
     * @summary Purchase Label with Shipment ID
     * @param {LabelsApiPurchaseLabelWithShipmentIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApiGenerated
     */
    public purchaseLabelWithShipmentId(requestParameters: LabelsApiPurchaseLabelWithShipmentIdRequest, options?: AxiosRequestConfig) {
        return LabelsApiFp(this.configuration).purchaseLabelWithShipmentId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
